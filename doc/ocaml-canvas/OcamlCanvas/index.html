<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>OcamlCanvas (ocaml-canvas.OcamlCanvas)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">ocaml-canvas</a> &#x00BB; OcamlCanvas</nav><header class="odoc-preamble"><h1>Module <code><span>OcamlCanvas</span></code></h1><p>The OCaml-Canvas library</p><p>The OCaml-Canvas library provides a portable Canvas framework for OCaml. It features an interface similar to HTML5 Canvas, and can render to native X11, MS Windows or macOS windows. It also features a small wrapper around HTML5 Canvas, allowing to use the library in any web browser. In addition, it allows to handle keyboard and mouse events.</p></header><nav class="odoc-toc"><ul><li><a href="#quick-start">Quick start</a></li><li><a href="#an-actual-example">An actual example</a></li></ul></nav><div class="odoc-content"><h2 id="quick-start"><a href="#quick-start" class="anchor"></a>Quick start</h2><p>Before using any function in the library (and assuming the <a href="V1/index.html"><code>OcamlCanvas.V1</code></a> module has been opened), the user should call <code>Backend</code>.init so that the library makes any internal initialization it needs for the current backend.</p><p>Once the backend is initialized, one can create Canvas objects using the <code>Canvas</code>.createOnscreen and <code>Canvas</code>.createOffscreen functions. The first one creates canvases contained in regular windows (which are simulated in the Javascript backend), while the second one creates canvases that are not rendered on screen, which can be useful to save complex images that can then simply be copied to a visible canvas. Onscreen canvases are hidden by default, and <code>Canvas</code>.show should be called on them to make them visible.</p><p>Drawing on a canvas can be perfomed using various drawing primitives, the most ubiquitous being <code>Canvas</code>.clearPath, <code>Canvas</code>.moveTo, <code>Canvas</code>.lineTo, <code>Canvas</code>.arc, <code>Canvas</code>.bezierCurveTo, <code>Canvas</code>.fill and <code>Canvas</code>.stroke. These functions allow to build a path step by step and either fill it completely or draw its outline. It is also possible to directly render some text with the <code>Canvas</code>.fillText and <code>Canvas</code>.strokeText functions.</p><p>The canvas drawing style can be customized using functions such as <code>Canvas</code>.setFillColor, <code>Canvas</code>.setStrokeColor or <code>Canvas</code>.setLineWidth. The font used to draw text can be specified with the <code>Canvas</code>.setFont function. It is also possible to apply various transformations to a canvas, such as translation, rotation and scaling, with the functions <code>Canvas</code>.transform, <code>Canvas</code>.translate, <code>Canvas</code>.scale, <code>Canvas</code>.rotate and <code>Canvas</code>.shear. All these styling elements can be saved and restored to/from a state stack using the functions <code>Canvas</code>.save and <code>Canvas</code>.restore.</p><p>Once the canvases are ready, we may start handling events for these canvases. To do so, we use the <code>Backend</code>.run function, which runs an event loop. This function MUST be the last instruction of the program. It takes a single argument, which is a function to be executed when the event loop has finished running. The event loop may be stopped by calling <code>Backend</code>.stop from any update function.</p><p>Each event reports at least the canvas on which it occured, and its timestamp. It may also report mouse coordinates for mouse events, or keyboard status for keyboard events.</p><h2 id="an-actual-example"><a href="#an-actual-example" class="anchor"></a>An actual example</h2><p>The following program creates a windowed canvas with an orange background, a cyan border, and the &quot;Hello world !&quot; text drawn rotated in the middle. The user may press the &quot;Escape&quot; key or close the window to exit the program. It will show the number of frames displayed when quitting.</p><pre class="language-ocaml"><code>open OcamlCanvas.V1

let () =

  Backend.init ();

  let c = Canvas.createOnscreen ~title:&quot;Hello world&quot;
            ~pos:(300, 200) ~size:(300, 200) () in

  Canvas.setFillColor c Color.orange;
  Canvas.fillRect c ~pos:(0.0, 0.0) ~size:(300.0, 200.0);

  Canvas.setStrokeColor c Color.cyan;
  Canvas.setLineWidth c 10.0;
  Canvas.clearPath c;
  Canvas.moveTo c (5.0, 5.0);
  Canvas.lineTo c (295.0, 5.0);
  Canvas.lineTo c (295.0, 195.0);
  Canvas.lineTo c (5.0, 195.0);
  Canvas.closePath c;
  Canvas.stroke c;

  Canvas.setFont c &quot;Liberation Sans&quot; ~size:36.0
    ~slant:Font.Roman ~weight:Font.bold;

  Canvas.setFillColor c (Color.of_rgb 0 64 255);
  Canvas.setLineWidth c 1.0;
  Canvas.save c;
  Canvas.translate c (150.0, 100.0);
  Canvas.rotate c (-. Const.pi_8);
  Canvas.fillText c &quot;Hello world !&quot; (-130.0, 20.0);
  Canvas.restore c;

  Canvas.show c;

  let e1 =
    React.E.map (fun { Event.canvas = _; timestamp = _; data = () } -&gt;
        Backend.stop ()
      ) Event.close
  in

  let e2 =
    React.E.map (fun { Event.canvas = _; timestamp = _;
                       data = { Event.key; char = _; flags = _ }; _ } -&gt;
        if key = KeyEscape then
          Backend.stop ()
      ) Event.key_down
  in

  let e3 =
    React.E.map (fun { Event.canvas = _; timestamp = _;
                       data = { Event.position = (x, y); button } } -&gt;
        Canvas.setFillColor c Color.red;
        Canvas.clearPath c;
        Canvas.arc c ~center:(float_of_int x, float_of_int y)
          ~radius:5.0 ~theta1:0.0 ~theta2:(2.0 *. Const.pi) ~ccw:false;
        Canvas.fill c ~nonzero:false
      ) Event.button_down
  in

  let frames = ref 0L in

  let e4 =
    React.E.map (fun { Event.canvas = _; timestamp = _ } -&gt;
        frames := Int64.add !frames Int64.one
      ) Event.frame
  in

  Backend.run (fun () -&gt;
      ignore e1; ignore e2; ignore e3; ignore e4;
      Printf.printf &quot;Displayed %Ld frames. Goodbye !\n&quot; !frames)</code></pre><div class="odoc-spec"><div class="spec module anchored" id="module-V1"><a href="#module-V1" class="anchor"></a><code><span><span class="keyword">module</span> <a href="V1/index.html">V1</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The OCaml-Canvas module is versioned. This is version 1. It is guaranteed that this interface will always remain compatible with existing programs, provided that the modules defined here ARE NEVER included in other modules nor opened globally. Local opens should be performed very carefully, as new identifiers may be introduced in modules and thus shadow any identifier defined before the open directive. An effort will be made to avoid introducing new identifiers that are of length 3 of less, or starting with a single character followed by an underscore. Hence such identifiers should be safe to use without risking to be shadowed.</p></div></div></div></body></html>