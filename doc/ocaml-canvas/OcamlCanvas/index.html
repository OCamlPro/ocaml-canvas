<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>OcamlCanvas (ocaml-canvas.OcamlCanvas)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">ocaml-canvas</a> &#x00BB; OcamlCanvas</nav><header class="odoc-preamble"><h1>Module <code><span>OcamlCanvas</span></code></h1><p>The OCaml-Canvas library</p><p>The OCaml-Canvas library provides a portable Canvas framework for OCaml. It features an interface similar to HTML5 Canvas, and can render to native X11, MS Windows or macOS windows. It also features a small wrapper around HTML5 Canvas, allowing to use the library in any web browser. In addition, it allows to handle keyboard and mouse events.</p></header><nav class="odoc-toc"><ul><li><a href="#quick-start">Quick start</a></li><li><a href="#an-actual-example">An actual example</a></li></ul></nav><div class="odoc-content"><h2 id="quick-start"><a href="#quick-start" class="anchor"></a>Quick start</h2><p>Before using any function in the library (and assuming the `OCamlCanvas.V1` module has been opened), the user should call <code>Backend</code>.init so that the library makes any internal initialization it needs for the current backend. This function takes as input a value of type <code>Backend</code>.options, allowing to tweak specific features of each backend. It is however recommended to simply use the default options, i.e <code>Backend</code>.default_options.</p><p>Once the backend is initialized, one can create Canvas objects using the <code>Canvas</code>.createFramed, <code>Canvas</code>.createFrameless and <code>Canvas</code>.createOffscreen functions. The first one creates a canvas contained in a regular window (which is simulated in the Javascript backend). The second one creates a window that has no decoration at all. The last one creates canvases that are not rendered on screen, which can be useful to save complex images that can then simply copied to a visible canvas. Onscreen canvases are hidden by default, and <code>Canvas</code>.show should be called on them to make them visible.</p><p>Drawing on a canvas can be perfomed using various drawing primitives, the most ubiquitous being <code>Canvas</code>.clearPath, <code>Canvas</code>.moveTo, <code>Canvas</code>.lineTo, <code>Canvas</code>.arc, <code>Canvas</code>.bezierCurveTo, <code>Canvas</code>.fill and <code>Canvas</code>.stroke. These functions allow to build a path step by step and either fill it completely or draw its outline. It is also possible to directly render some text with the <code>Canvas</code>.fillText and <code>Canvas</code>.strokeText functions.</p><p>The canvas drawing style can be customized using functions such as <code>Canvas</code>.setFillColor, <code>Canvas</code>.setStrokeColor or <code>Canvas</code>.setLineWidth. The font used to draw text can be specified with the <code>Canvas</code>.setFont function. It is also possible to apply various transformations to a canvas, such as translation, rotation and scaling, with the functions <code>Canvas</code>.transform, <code>Canvas</code>.translate, <code>Canvas</code>.scale, <code>Canvas</code>.rotate and <code>Canvas</code>.shear. All these styling elements can be saved and restored to/from a state stack using the functions <code>Canvas</code>.save and <code>Canvas</code>.restore.</p><p>Once the canvases are ready, we may start handling events for these canvases. To do so, we use the <code>Backend</code>.run function, which runs an event loop. This function MUST be the last instruction of the program. It takes three arguments: the first one is an event handler function, the second one is is executed when the event loop has finished running, and the third one is an initial state of an arbitrary type. The event loop may be stopped by calling <code>Backend</code>.stop from the event handler.</p><p>The event handler function takes two arguments: a state, and an event description. It should pattern-match the event against the various constructors of the <code>Event</code>.t type it is interested in, and return a pair consisting of the new state and a boolean value indicating whether the event was processed (for some events, this may have some side-effect, indicated in the event's description). Each event reports at least the canvas on which it occured, and its timestamp. It may also report mouse coordinates for mouse events, or keyboard status for keyboard events.</p><h2 id="an-actual-example"><a href="#an-actual-example" class="anchor"></a>An actual example</h2><p>The following program creates a windowed canvas with an orange background, a cyan border, and the &quot;Hello world !&quot; text drawn rotated in the middle. The user may press the &quot;Escape&quot; key or close the window to exit the program. It will show the number of frames displayed when quitting.</p><pre><code>open OCamlCanvas.V1

let () =

  Backend.(init default_options);

  let c = Canvas.createFramed &quot;Hello world&quot;
            ~pos:(300, 200) ~size:(300, 200) in

  Canvas.setFillColor c Color.orange;
  Canvas.fillRect c ~pos:(0.0, 0.0) ~size:(300.0, 200.0);

  Canvas.setStrokeColor c Color.cyan;
  Canvas.setLineWidth c 10.0;
  Canvas.clearPath c;
  Canvas.moveTo c (5.0, 5.0);
  Canvas.lineTo c (295.0, 5.0);
  Canvas.lineTo c (295.0, 195.0);
  Canvas.lineTo c (5.0, 195.0);
  Canvas.closePath c;
  Canvas.stroke c;

  Canvas.setFont c &quot;Liberation Sans&quot; ~size:36.0
    ~slant:Font.Roman ~weight:Font.bold;

  Canvas.setFillColor c (Color.of_rgb 0 64 255);
  Canvas.setLineWidth c 1.0;
  Canvas.save c;
  Canvas.translate c (150.0, 100.0);
  Canvas.rotate c (-. Float.pi /. 8.0);
  Canvas.fillText c &quot;Hello world !&quot; (-130.0, 20.0);
  Canvas.restore c;

  Canvas.show c;

  Backend.run (fun state -&gt; function

    | Event.CanvasClosed { canvas = _; timestamp = _ } -&gt;
        Backend.stop ();
        state, true

    | Event.KeyAction { canvas = _; timestamp = _; key;
                        char = _; flags = _; state = Down } -&gt;
        if key = Event.KeyEscape then
          Backend.stop ();
        state, true

    | Event.ButtonAction { canvas = _; timestamp = _; position = (x, y);
                           button = _; state = Down } -&gt;
        Canvas.setFillColor c Color.red;
        Canvas.clearPath c;
        Canvas.arc c ~center:(float_of_int x, float_of_int y)
          ~radius:5.0 ~theta1:0.0 ~theta2:(pi *. 2.0) ~ccw:false;
        Canvas.fill c ~nonzero:false;
        state, true

    | Event.Frame { canvas = _; timestamp = _ } -&gt;
        Int64.add state Int64.one, true

    | _ -&gt;
        state, false

  ) (fun state -&gt;
      Printf.printf &quot;Displayed %Ld frames. Goodbye !\n&quot; state
  ) 0L</code></pre><div class="odoc-spec"><div class="spec module" id="module-V1" class="anchored"><a href="#module-V1" class="anchor"></a><code><span><span class="keyword">module</span> <a href="V1/index.html">V1</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The OCaml-Canvas module is versioned. This is version 1.</p></div></div></div></body></html>